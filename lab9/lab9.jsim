* Candari, Roger II
* Lluisma, Arthur Jed
* Reyes, Francesca Dominique

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* ALU
* see lab 6

* the full adder
.subckt fa a b carry_in sum carry_out
* the sum
Xfirst a b subout1 xor2
Xsecond subout1 carry_in sum xor2
* the carry
Xthird subout1 carry_in subout2 nand2
Xfourth a b subout3 nand2
Xfifth subout2 subout3 carry_out nand2
.ends

* the 32-bit full adder
.subckt add32 a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]
Xbit[31:0] a[31:0] b[31:0] c_out[30:0] c_in0 sum[31:0] c_out[31:0] fa
.ends

* the 32-bit counter
.subckt counter32 reset a[31:0] f[31:0] clk
Xadd a[31:0] f[31:0] 0 sum[31:0] c_out1 c_out2 add32
Xmux[31:0] reset#32 sum[31:0] 0#32 z[31:0] mux2
Xdreg[31:0] z[31:0] clk#32 f[31:0] dreg
.ends

* the 32-bit adder/subtractor
.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
Xor b[31:0] op0#32 finalb[31:0] xor2
Xadd a[31:0] finalb[31:0] op0 fas[31:0] out[31:30] add32
* get n
.connect fas31 n
* get v
Xv out31 out30 v xor2
* get z
Xnor fas[31:16] fas[15:0] norout[15:0] nor2
Xnand1 norout[15:8] norout[7:0] nand1out[7:0] nand2
Xnor1 nand1out[7:4] nand1out[3:0] nor1out[3:0] nor2
Xnand2 nor1out[3:2] nor1out[1:0] nand2out[1:0] nand2
Xnor2 nand2out1 nand2out0 z nor2
.ends

* the 32-bit comparator
.subckt cmp32 n v z op[2:1] fcmp[31:0]
*if op1 = 1, check for a = b, z = 1
Xcheckeq op1 z op1nandz nand2
*if op2 = 1, check for a < b, n = 1
Xchecknv n v tempout xor2
Xcheckless op2 tempout op2nandtemp nand2
*if op1 op2 = 1, check for a < b or a = b
Xfinalcheck op1nandz op2nandtemp fcmp0 nand2
.connect 0 fcmp[31:1]
.ends

* the 32-bit bool
.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
Xmux a[31:0] b[31:0] op0#32 op1#32 op2#32 op3#32 fbool[31:0] mux4
.ends

* the 32-bit shifter
.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]
Xfill a31 op1 fll and2
Xflipin op0#32 a[0:31] a[31:0] in[31:0] mux2    
X16shift b4#32 in[31:0] fll#16 in[31:16] 16temp[31:0] mux2
X8shift b3#32 16temp[31:0] fll#8 16temp[31:8]  8temp[31:0] mux2
X4shift b2#32 8temp[31:0] fll#4 8temp[31:4]  4temp[31:0] mux2
X2shift b1#32 4temp[31:0] fll#2 4temp[31:2]  2temp[31:0] mux2
X1shift b0#32 2temp[31:0] fll#1 2temp[31:1]  1temp[31:0] mux2
Xflipfn op0#32 1temp[0:31] 1temp[31:0] fshift[31:0] mux2
.ends

* the 32-bit alu
.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]
Xas a[31:0] b[31:0] alufn0 f1_[31:0] n v z as32
Xbool a[31:0] b[31:0] alufn[3:0] f2_[31:0] bool32
Xshift a[31:0] b[4:0] alufn[1:0] f3_[31:0] shift32
Xcmp n v z alufn[2:1] f4_[31:0] cmp32
Xmux alufn5#32 alufn4#32 f1_[31:0] f3_[31:0] f2_[31:0] f4_[31:0] f[31:0] mux4
.ends

*******************************************************************************
* Instruction / Data Memory File
* see lab 8

Xmemory  vdd  0    0   pc[8:2]    inst[31:0]
+        vdd  0    0   mema[8:2]  memrd[31:0]
+        0    clk  wr  mema[8:2]  memwd[31:0]
+ $memory width=32 nlocations=128 file="lab7.bin"

*******************************************************************************
* Register File
* see lab 8

Xregisters  vdd  0    0      ra1_[4:0]  rd1_[31:0]
+           vdd  0    0      ra2_[4:0]  rd2_[31:0]
+           0    clk  werf_  wa[4:0]    wd[31:0]
+ $memory width=32 nlocations=32 contents=(
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+ )

Xcheck1 wa[4:1] z1 and4
Xcheck2 wa0 z1 z2 and2
Xwerf z2 werf 0 werf_ mux2

*******************************************************************************
* Control Logic
* see lab 8

Xcontrol  vdd  0  0  z opcode[5:0] control[13:0]
+ $memory width=14 nlocations=128 contents=(
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b00000000000001 0b01000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b01000000000001 0b00000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+ )

* helper subckt
.subckt join S T
  .connect S T
.ends

Xjcontrola control[13:12] pcsel[1:0]   join
Xjcontrolb control11      ra2sel       join
Xjcontrolc control10      bsel         join
Xjcontrold control[9:8]   wdsel[1:0]   join
Xjcontrole control[7:2]   alufn[5:0]   join
Xjcontrolf control1       wr_control   join
Xjcontrolg control0       werf_control join

Xjinsta inst[31:26] opcode[5:0] join
Xjinstb inst[25:21] rc[4:0]     join
Xjinstc inst[20:16] ra[4:0]     join
Xjinstd inst[15:11] rb[4:0]     join
Xjinste inst[15:0]  c[15:0]     join

*******************************************************************************
* MUXs for PCSEL, RA2SEL, BSEL, WDSEL

Xpcsel_ pcsel0#7 pcsel1#7 pcincrement[8:2] branch[8:2] rd1_[8:2] pc[8:2] pc_res[8:2] mux4

*******************************************************************************
* NOR gate for Z

*******************************************************************************
* Program Counter (PC)
* replace the one here with the working program counter!

Xpc pc_in[8:2] clk2#7 pc[8:2] dreg
Xpcincrement pc[8:2] 0#7 pc_carry_out[7:2] vdd pcincrement[8:2] pc_carry_out[8:2] fa
.connect 0 pc[1:0]

*******************************************************************************
* Jump Target (JT)

*******************************************************************************
* Branch Target (PC + 4 + 4C)

Xpcbeq pcincrement[8:2] c[6:0] branch_carry_out[7:2] 0 branch[8:2] branch_carry_out[8:2] fa

*******************************************************************************
* Reset Logic

Wreset reset nrz(0, 5, 10ns, 0ns, 0.001ns, 0.001ns) 1 0
Xreset reset#9 control1 control0 pc_res[8:2] 0#9 wr werf pc_in[8:2] mux2

*******************************************************************************
* Other Stuff

* temporarily connect signals
.connect vdd clk ra1_[4:0] ra2_[4:0] wa[4:0] wd[31:0] mema[8:0] memwd[31:0]
.connect 0 z

* plot some signals together
Xjdisplaya ra2_b_wdsel[3:0] ra2sel bsel wdsel[1:0] join
Xjdisplayb wr_werfs[2:0]    wr werf werf_          join

* plot the signals
.tran 1280ns
.plot clk2
.plot pc[8:0]
.plot betaop(opcode[5:0])
.plot d(ra[4:0])
.plot d(rb[4:0])
.plot d(rc[4:0])
.plot sd(c[15:0])
.plot b(pcsel[1:0])
.plot b(ra2_b_wdsel[3:0])
.plot b(alufn[5:0])
.plot b(wr_werfs[2:0])
.plot sd(rd1_[31:0])
.plot sd(rd2_[31:0])
.plot sd(wd[31:0])
.plot d(mema[8:0])
.plot sd(memrd[31:0])
.plot sd(memwd[31:0])
